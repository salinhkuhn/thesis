% Some commands used in this file
\newcommand{\package}{\emph}

\chapter{Introduction}
Lean [1,2] is a proof assistant and purely functional programming language, providing users with a tool for interactive theorem proving and software development. Lean itself offers a compiler that produces fast native code, which is written by translating Lean source code into Lean's core language, which will then be subsequently lowered to LLVM IR and then via the LLVM backend compiled into machine code specific for the target architecture [3]. As this compilation path leverages the optimizations and backend provided by LLVM to produce fast code, it heavily relies on the LLVM compiler toolchain. 

The Lean compiler is used not only to produce executables from Lean source code but is also crucial in a style of proof called 'proof by reflection' where a computation is executed, and the output of the computation is used as a certificate for a proof. This use of the compiler for proving makes verifying the Lean compiler an important research target, since the trustworthiness of fast proof by reflection in Lean hinges on the trustworthiness of its compiler toolchain. However, LLVM's large codebase with numerous optimization passes makes such a verification complex [4]. Full verification of Lean's compilation process is unlikely as it requires a fully verified LLVM compiler, while verification efforts for LLVM currently only cover its higher-level stacks around LLVM-IR (e.g., Vellvm [5]) and also only exist in ROCQ [6]. As a first step towards a verified Lean backend, with an eye towards providing trustworthy proof by reflection for Lean, this work proposes to develop a verified instruction selection pipeline that translates LLVM IR into an ISA, here choosen to be RISC-V, to produce fast machine-specific code. This verified instruction selection pipeline aims to provide formal guarantees that the RISC-V assembly code generated from Lean source programs stays semantically equivalent to the LLVM IR representation of the program in Lean’s core language. While the actual connection to Lean’s core language is a non-goal, we will focus in this project on the subset of LLVM-IR that would typically be generated by Lean, e.g., LLVM-IR consisting of load/store operations plus integer arithmetic.

To implement such a formally verified instruction selection pass, we leverage and build upon existing RISC-V and LLVM specifications and publically available datasets of peephole optimizations (e.g., from the GCC compiler backend). The Lean-MLIR project [7] already provides a semantic model of the arithmetic fragment of LLVM, which can be used as a starting point for the needed LLVM semantics. RISC-V semantics are also well-defined and given in a formal specification by the SAIL project1 [8]. Additionally, compiler backends like in GCC or LLVM provide a repository with an extensive collection of peephole optimization patterns, which we could adapt to an LLVM-like abstract ISA and leverage to write our verified instruction selection pipeline to generate optimized machine code.

We shall use the insights from projects like Peek [9], which implements a peephole optimization pass for x86 in CompCERT [10]. In this work, we will integrate the use of verification tools to formally show the semantic equivalence of the LLVM IR instructions to be lowered and our generated RISC-V lowering. Leveraging bv\underline decide [7], the first fully verified SMT solver natively integrated into an interactive theorem prover, we gain significantly more proof automation compared to other projects like CompCert. Therefore, we shall attempt to automate many of these proofs using SMT-LIB compatible proof automation ( bv \underline decide) and Lean’s extensive bit vector library.
